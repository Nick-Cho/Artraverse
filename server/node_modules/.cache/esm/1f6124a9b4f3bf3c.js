let Post,User,cloudinary;_b4f‍.x([["createPost",()=>createPost],["uploadImage",()=>uploadImage],["postsByUser",()=>postsByUser]]);_b4f‍.w("../models/post",[["default",["Post"],function(v){Post=v}]]);_b4f‍.w("../models/user",[["default",["User"],function(v){User=v}]]);_b4f‍.w("cloudinary",[["default",["cloudinary"],function(v){cloudinary=v}]]);



cloudinary.config({
  cloud_name: process.env.CLOUDINARY_NAME,
  api_key: process.env.CLOUDINARY_KEY,
  api_secret: process.env.CLOUDINARY_SECRET,
})
       async function createPost(req,res) {
  // console.log('post received in controller: ', req.body)
  const {content, image} = req.body;
  if(!image){
    return res.status(400).send({
      message: "Content is required"
    });
  }
  try{
    const user = await User.findById(req.user._id);
    
    const post = new Post({content, image, postedBy: {first_name: user.first_name}});
    _b4f‍.g.console.log(post.postedBy);
    post.save();
    res.json(post);
  } catch(err) {
    _b4f‍.g.console.log(err);
    res.sendStatus(400);
  }
}

       async function uploadImage(req,res){
  //console.log("request files:", req.files);
  try{
    const result = await cloudinary.uploader.upload(req.files.image.path);
    //console.log("uploaded image url:", result);
    res.json({
      url: result.secure_url,
      public_id: result.public_id,
    })
  } catch(err){
    _b4f‍.g.console.log(err);
  }
};

       const postsByUser = async (req,res) => {
  try{
    const posts = await Post.find({postedBy: req.user._id})
    .populate('postedBy', "name _id image")
    .sort({createdAt: -1}) // filters by newest post
    .limit(9); //limits to 9 posts
    _b4f‍.g.console.log("posts after populated: ", posts);
    res.json(posts);
  } catch(err){
    _b4f‍.g.console.log(err);
  }
}